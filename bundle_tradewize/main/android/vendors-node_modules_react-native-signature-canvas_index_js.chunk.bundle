(self.webpackChunksas_main=self.webpackChunksas_main||[]).push([["vendors-node_modules_react-native-signature-canvas_index_js"],{50590:function(n,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return e}});var e=function(n){return`<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>Signature Canvas</title>\n  <meta name="description" content="Signature Pad - HTML5 canvas based smooth signature drawing using variable width spline interpolation.">\n\n  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">\n\n  <meta name="apple-mobile-web-app-capable" content="yes">\n  <meta name="apple-mobile-web-app-status-bar-style" content="black">\n\n  <style>\n    body {\n      font-family: Helvetica, Sans-Serif;\n    \n      -moz-user-select: none;\n      -webkit-user-select: none;\n      -ms-user-select: none;\n      margin:0;\n      overflow:hidden;\n    }\n    body,html {\n      width: 100%;\n      height: 300px;\n    }\n    * {\n        box-sizing: border-box;\n        margin: 0;\n        padding: 0;\n    }\n    \n    .rotated-true {\n      transform: rotate(90deg);\n      transform-origin:bottom left;\n      \n      position:absolute;\n      top: -100vw;\n      left: 0;\n      \n      height:100vw;\n      width:100vh;\n      \n      overflow:auto;\n    }\n    .rotated-false {\n      width: 100%;\n      height: 100%;\n    }\n    .m-signature-pad {\n      font-size: 10px;\n      width: 100%;\n      height: 100%;\n      border: 1px solid #e8e8e8;\n      background-color: #fff;\n      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.08) inset;\n    }\n    \n    .m-signature-pad--body {\n      position: relative;\n      height: 100%;\n      border: 1px solid #f4f4f4;\n    }\n    \n    .m-signature-pad--body\n      canvas {\n        position: absolute;\n        left: 0;\n        top: 0;\n        width: 100%;\n        height: 100%;\n        border-radius: 4px;\n        box-shadow: 0 0 5px rgba(0, 0, 0, 0.02) inset;\n      }\n    \n    .m-signature-pad--footer {\n      padding: 0px 20px;\n      margin-top: 10px;\n      position: relative;\n      height: 40px;\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n    }\n    \n    .m-signature-pad--footer\n      .description {\n        color: #C3C3C3;\n        text-align: center;\n        font-size: 1.2em;\n      }\n    \n    .m-signature-pad--footer\n      .button {\n        background-color: #3F99F7;\n        height: 32px;\n        padding: 0 20px;\n        line-height: 32px;\n        text-align: center;\n        color: #FFF;\n        border: 1px solid transparent;\n        border-radius: 4px;\n        outline: none;\n        box-shadow: none;\n      }\n    \n    .m-signature-pad--footer\n      .button.clear {\n      }\n    \n    .m-signature-pad--footer\n      .button.save {\n      }\n    \n    @media screen and (max-width: 1024px) {\n      .m-signature-pad {\n        width: 100%;\n        height: 100%;\n      }\n      #github {\n        display: none;\n      }\n    }\n    \n    @media screen and (min-device-width: 768px) and (max-device-width: 1024px) {\n      .m-signature-pad {\n        margin: 10%;\n      }\n    }\n    \n    @media screen and (max-height: 320px) {\n      .m-signature-pad--body {\n        left: 0;\n        right: 0;\n        top: 0;\n        bottom: 32px;\n      }\n      .m-signature-pad--footer {\n        left: 20px;\n        right: 20px;\n        bottom: 4px;\n        height: 28px;\n      }\n      .m-signature-pad--footer\n        .description {\n          font-size: 1em;\n          margin-top: 1em;\n        }\n    }\n    <%style%>\n    </style>\n</head>\n<body onselectstart="return false">\n  <div class="rotated-<%orientation%>">\n    <div id="signature-pad" class="m-signature-pad">\n      <div class="m-signature-pad--body">\n        <img style="position: absolute; top: 0; left: 0; pointer-events: none;" src=<%bgSrc%> width=<%bgWidth%> height=<%bgHeight%> />\n        <canvas></canvas>\n        <img style="position: absolute; top: 0; left: 0; pointer-events: none;" src=<%overlaySrc%> width=<%overlayWidth%> height=<%overlayHeight%> />\n      </div>\n      <div class="m-signature-pad--footer">\n        <button type="button" class="button clear" data-action="clear"><%clear%></button>\n        <div class="description"><%description%></div>\n        <button type="button" class="button save" data-action="save"><%confirm%></button>\n      </div>\n    </div>\n  </div>\n\n  <script>\n    ${n}\n  <\/script>\n</body>\n</html>`}},9152:function(n,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return e}});var e='\n    // Enhanced error handling and validation\n    var wrapper = document.getElementById("signature-pad"),\n        clearButton = wrapper && wrapper.querySelector("[data-action=clear]"),\n        saveButton = wrapper && wrapper.querySelector("[data-action=save]"),\n        canvas = wrapper && wrapper.querySelector("canvas"),\n        signaturePad;\n        \n    if (!wrapper || !canvas) {\n        console.error(\'Required DOM elements not found\');\n    }\n    \n    // Enhanced canvas resize with debouncing\n    function debounce(func, wait) {\n        var timeout;\n        return function executedFunction() {\n            var later = function() {\n                clearTimeout(timeout);\n                func.apply(this, arguments);\n            };\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n        };\n    }\n    \n    function resizeCanvas() {\n        if (!canvas || !canvas.getContext) {\n            console.warn(\'Canvas not available for resize\');\n            return;\n        }\n        \n        try {\n            var context = canvas.getContext("2d");\n            var imgData = signaturePad ? signaturePad.toData() : null;\n            var ratio = Math.max(window.devicePixelRatio || 1, 1);\n            \n            canvas.width = canvas.offsetWidth * ratio;\n            canvas.height = canvas.offsetHeight * ratio;\n            context.scale(ratio, ratio);\n            \n            if (imgData && signaturePad) {\n                signaturePad.fromData(imgData);\n            }\n        } catch (error) {\n            console.error(\'Error resizing canvas:\', error);\n        }\n    }\n    \n    // Use debounced resize handler\n    var debouncedResize = debounce(resizeCanvas, 100);\n    window.addEventListener(\'resize\', debouncedResize);\n    resizeCanvas();\n    \n    signaturePad = new SignaturePad(canvas, {\n        onBegin: () => window.ReactNativeWebView.postMessage("BEGIN"),\n        onEnd: () => window.ReactNativeWebView.postMessage("END"),\n        penColor: \'<%penColor%>\',\n        backgroundColor: \'<%backgroundColor%>\',\n        dotSize: <%dotSize%>,\n        minWidth: <%minWidth%>,\n        maxWidth: <%maxWidth%>,\n        minDistance: <%minDistance%>,\n    });\n\n    function clearSignature () {\n        signaturePad.clear();\n        window.ReactNativeWebView.postMessage("CLEAR");\n    }\n    \n    function undo() {\n        signaturePad.undo();\n        window.ReactNativeWebView.postMessage("UNDO");\n    }\n    \n    function redo() {\n        signaturePad.redo();\n        window.ReactNativeWebView.postMessage("REDO");\n      }\n\n    function changePenColor(color) {\n        if (!signaturePad) {\n            console.warn(\'SignaturePad not initialized\');\n            return;\n        }\n        \n        signaturePad.penColor = color;\n        window.ReactNativeWebView && window.ReactNativeWebView.postMessage("CHANGE_PEN");\n    }\n\n    function changePenSize(minW, maxW) {\n        if (!signaturePad) {\n            console.warn(\'SignaturePad not initialized\');\n            return;\n        }\n        \n        // Validate numeric values\n        if (typeof minW !== \'number\' || typeof maxW !== \'number\' || minW < 0 || maxW < minW) {\n            console.warn(\'Invalid pen size values:\', minW, maxW);\n            return;\n        }\n        \n        signaturePad.minWidth = minW;\n        signaturePad.maxWidth = maxW;\n        window.ReactNativeWebView && window.ReactNativeWebView.postMessage("CHANGE_PEN_SIZE");\n    }\n    \n    function getData () {\n        var data = signaturePad.toData();\n        window.ReactNativeWebView.postMessage(JSON.stringify(data));\n    }\n\n    function fromData (pointGroups) {\n        signaturePad.fromData(pointGroups);\n        window.ReactNativeWebView.postMessage(JSON.stringify(pointGroups));\n    }\n\n    function draw() {\n      signaturePad.draw();\n      window.ReactNativeWebView.postMessage("DRAW");\n    }\n\n    function erase() {\n      signaturePad.erase();\n      window.ReactNativeWebView.postMessage("ERASE");\n    }\n\n    function cropWhitespace(url) {\n        var myImage = new Image();\n        myImage.crossOrigin = "Anonymous";\n        myImage.onload = function(){\n            window.ReactNativeWebView.postMessage(removeImageBlanks(myImage)); //Will return cropped image data\n        }\n        myImage.src = url;\n\n        //-----------------------------------------//\n        function removeImageBlanks(imageObject) {\n            var imgWidth = imageObject.width;\n            var imgHeight = imageObject.height;\n            var canvas = document.createElement(\'canvas\');\n            canvas.setAttribute("width", imgWidth);\n            canvas.setAttribute("height", imgHeight);\n            var context = canvas.getContext(\'2d\');\n            context.drawImage(imageObject, 0, 0);\n\n            var imageData = context.getImageData(0, 0, imgWidth, imgHeight),\n                data = imageData.data,\n                getRGB = function(x, y) {\n                    if (x < 0 || x >= imgWidth || y < 0 || y >= imgHeight) {\n                        return { red: 255, green: 255, blue: 255, opacity: 255 };\n                    }\n                    var offset = imgWidth * y + x;\n                    return {\n                        red:     data[offset * 4],\n                        green:   data[offset * 4 + 1],\n                        blue:    data[offset * 4 + 2],\n                        opacity: data[offset * 4 + 3]\n                    };\n                },\n                isWhite = function (rgb) {\n                    // many images contain noise, as the white is not a pure #fff white\n                    return !rgb.opacity || (rgb.red > 200 && rgb.green > 200 && rgb.blue > 200);\n                },\n                        scanY = function (fromTop) {\n                var offset = fromTop ? 1 : -1;\n\n                // loop through each row\n                for(var y = fromTop ? 0 : imgHeight - 1; fromTop ? (y < imgHeight) : (y > -1); y += offset) {\n\n                    // loop through each column\n                    for(var x = 0; x < imgWidth; x++) {\n                        var rgb = getRGB(x, y);\n                        if (!isWhite(rgb)) {\n                            if (fromTop) {\n                                return y;\n                            } else {\n                                return Math.min(y + 1, imgHeight);\n                            }\n                        }\n                    }\n                }\n                return null; // all image is white\n            },\n            scanX = function (fromLeft) {\n                var offset = fromLeft? 1 : -1;\n\n                // loop through each column\n                for(var x = fromLeft ? 0 : imgWidth - 1; fromLeft ? (x < imgWidth) : (x > -1); x += offset) {\n\n                    // loop through each row\n                    for(var y = 0; y < imgHeight; y++) {\n                        var rgb = getRGB(x, y);\n                        if (!isWhite(rgb)) {\n                            if (fromLeft) {\n                                return x;\n                            } else {\n                                return Math.min(x + 1, imgWidth);\n                            }\n                        }      \n                    }\n                }\n                return null; // all image is white\n            };\n\n            var cropTop = scanY(true),\n                cropBottom = scanY(false),\n                cropLeft = scanX(true),\n                cropRight = scanX(false),\n                cropWidth = cropRight - cropLeft,\n                cropHeight = cropBottom - cropTop;\n\n            canvas.setAttribute("width", cropWidth);\n            canvas.setAttribute("height", cropHeight);\n            // finally crop the guy\n            canvas.getContext("2d").drawImage(imageObject,\n                cropLeft, cropTop, cropWidth, cropHeight,\n                0, 0, cropWidth, cropHeight);\n\n            return canvas.toDataURL(\'<%imageType%>\');\n        }\n    }\n\n    function readSignature() {\n        if (!signaturePad) {\n            console.warn(\'SignaturePad not initialized\');\n            return;\n        }\n        \n        try {\n            if (signaturePad.isEmpty()) {\n                window.ReactNativeWebView && window.ReactNativeWebView.postMessage("EMPTY");\n            } else {\n                var imageType = \'<%imageType%>\' || \'image/png\';\n                var url = signaturePad.toDataURL(imageType);\n                \n                if (trimWhitespace === true) {\n                    cropWhitespace(url);\n                } else {\n                    window.ReactNativeWebView && window.ReactNativeWebView.postMessage(url);\n                }\n                \n                if (autoClear === true && signaturePad) {\n                    signaturePad.clear();\n                }\n            }\n        } catch (error) {\n            console.error(\'Error reading signature:\', error);\n        }\n    }\n\n    var autoClear = <%autoClear%>;\n    \n    var trimWhitespace = <%trimWhitespace%>;\n\n    var dataURL = \'<%dataURL%>\';\n\n    if (dataURL) signaturePad.fromDataURL(dataURL);\n\n    if (clearButton) {\n        clearButton.addEventListener("click", clearSignature);\n    }\n\n    // Prevent race conditions by sequencing operations\n    if (saveButton) {\n        saveButton.addEventListener("click", function() {\n            try {\n                readSignature();\n                // Small delay to prevent race condition\n                setTimeout(function() {\n                    getData();\n                }, 10);\n            } catch (error) {\n                console.error(\'Error in save button click:\', error);\n            }\n        });\n    }\n'},17751:function(n,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return e}});var e='\n/*!\n * Signature Pad v3.0.0-beta.3 | https://github.com/szimek/signature_pad\n * (c) 2018 Szymon Nowak | Released under the MIT license\n */\n\n(function (global, factory) {\n  typeof exports === \'object\' && typeof module !== \'undefined\' ? module.exports = factory() :\n  typeof define === \'function\' && define.amd ? define(factory) :\n  (global.SignaturePad = factory());\n}(this, (function () { \'use strict\';\n\n  var Point = (function () {\n      function Point(x, y, time) {\n          this.x = x;\n          this.y = y;\n          this.time = time || Date.now();\n      }\n      Point.prototype.distanceTo = function (start) {\n          return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n      };\n      Point.prototype.equals = function (other) {\n          return this.x === other.x && this.y === other.y && this.time === other.time;\n      };\n      Point.prototype.velocityFrom = function (start) {\n          return this.time !== start.time\n              ? this.distanceTo(start) / (this.time - start.time)\n              : 0;\n      };\n      return Point;\n  }());\n\n  var Bezier = (function () {\n      function Bezier(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n          this.startPoint = startPoint;\n          this.control2 = control2;\n          this.control1 = control1;\n          this.endPoint = endPoint;\n          this.startWidth = startWidth;\n          this.endWidth = endWidth;\n      }\n      Bezier.fromPoints = function (points, widths) {\n          var c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n          var c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n          return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n      };\n      Bezier.calculateControlPoints = function (s1, s2, s3) {\n          var dx1 = s1.x - s2.x;\n          var dy1 = s1.y - s2.y;\n          var dx2 = s2.x - s3.x;\n          var dy2 = s2.y - s3.y;\n          var m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };\n          var m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };\n          var l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n          var l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n          var dxm = m1.x - m2.x;\n          var dym = m1.y - m2.y;\n          var k = l2 / (l1 + l2);\n          var cm = { x: m2.x + dxm * k, y: m2.y + dym * k };\n          var tx = s2.x - cm.x;\n          var ty = s2.y - cm.y;\n          return {\n              c1: new Point(m1.x + tx, m1.y + ty),\n              c2: new Point(m2.x + tx, m2.y + ty)\n          };\n      };\n      Bezier.prototype.length = function () {\n          var steps = 10;\n          var length = 0;\n          var px;\n          var py;\n          for (var i = 0; i <= steps; i += 1) {\n              var t = i / steps;\n              var cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n              var cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n              if (i > 0) {\n                  var xdiff = cx - px;\n                  var ydiff = cy - py;\n                  length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n              }\n              px = cx;\n              py = cy;\n          }\n          return length;\n      };\n      Bezier.prototype.point = function (t, start, c1, c2, end) {\n          return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))\n              + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)\n              + (3.0 * c2 * (1.0 - t) * t * t)\n              + (end * t * t * t);\n      };\n      return Bezier;\n  }());\n\n  function throttle(fn, wait) {\n      if (wait === void 0) { wait = 250; }\n      var previous = 0;\n      var timeout = null;\n      var result;\n      var storedContext;\n      var storedArgs;\n      var later = function () {\n          previous = Date.now();\n          timeout = null;\n          result = fn.apply(storedContext, storedArgs);\n          if (!timeout) {\n              storedContext = null;\n              storedArgs = [];\n          }\n      };\n      return function wrapper() {\n          var args = [];\n          for (var _i = 0; _i < arguments.length; _i++) {\n              args[_i] = arguments[_i];\n          }\n          var now = Date.now();\n          var remaining = wait - (now - previous);\n          storedContext = this;\n          storedArgs = args;\n          if (remaining <= 0 || remaining > wait) {\n              if (timeout) {\n                  clearTimeout(timeout);\n                  timeout = null;\n              }\n              previous = now;\n              result = fn.apply(storedContext, storedArgs);\n              if (!timeout) {\n                  storedContext = null;\n                  storedArgs = [];\n              }\n          }\n          else if (!timeout) {\n              timeout = window.setTimeout(later, remaining);\n          }\n          return result;\n      };\n  }\n\n  var SignaturePad = (function () {\n      function SignaturePad(canvas, options) {\n          if (options === void 0) options = {};\n          var _this = this;\n          this.canvas = canvas;\n          this.options = options;\n          this._startingSignature = null;\n          this._isDrawing = true;\n          this._history = [];\n          this._handleMouseDown = function (event) {\n              if (event.which === 1) {\n                  _this._mouseButtonDown = true;\n                  _this._strokeBegin(event);\n              }\n          };\n          this._handleMouseMove = function (event) {\n              if (_this._mouseButtonDown) {\n                  _this._strokeMoveUpdate(event);\n              }\n          };\n          this._handleMouseUp = function (event) {\n              if (event.which === 1 && _this._mouseButtonDown) {\n                  _this._mouseButtonDown = false;\n                  _this._strokeEnd(event);\n              }\n          };\n          this._handleTouchStart = function (event) {\n              event.preventDefault();\n              if (event.targetTouches.length === 1) {\n                  var touch = event.changedTouches[0];\n                  _this._strokeBegin(touch);\n              }\n          };\n          this._handleTouchMove = function (event) {\n              event.preventDefault();\n              var touch = event.targetTouches[0];\n              _this._strokeMoveUpdate(touch);\n          };\n          this._handleTouchEnd = function (event) {\n              var wasCanvasTouched = event.target === _this.canvas;\n              if (wasCanvasTouched) {\n                  event.preventDefault();\n                  var touch = event.changedTouches[0];\n                  _this._strokeEnd(touch);\n              }\n          };\n          this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n          this.minWidth = options.minWidth || 0.5;\n          this.maxWidth = options.maxWidth || 2.5;\n          this.throttle = "throttle" in options ? options.throttle : 16;\n          this.minDistance = "minDistance" in options ? options.minDistance : 5;\n          this._strokeMoveUpdate = this.throttle\n            ? (this._strokeMoveUpdate = throttle(\n                SignaturePad.prototype._strokeUpdate,\n                this.throttle\n              ))\n            : SignaturePad.prototype._strokeUpdate;\n          this.dotSize = options.dotSize || function dotSize() {return (this.minWidth + this.maxWidth) / 2;};\n          this.penColor = options.penColor || "black";\n          this.backgroundColor = options.backgroundColor || "rgba(255,255,255,0)";\n          this.onBegin = options.onBegin;\n          this.onEnd = options.onEnd;\n          this._ctx = canvas.getContext("2d");\n          this.clear();\n          this.on();\n      }\n      SignaturePad.prototype.clear = function () {\n          var ctx = this._ctx;\n          var canvas = this.canvas;\n          ctx.fillStyle = this.backgroundColor;\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n          this._data = [];\n          this._reset();\n          this._isEmpty = true;\n      };\n      SignaturePad.prototype.undo = function () {\n        const data = this.toData();\n        if (data && data.length) {\n            this._history.push(data.pop()); // remove the last stroke\n        } else if (this._startingSignature) {\n            return; // they performed undo of background sig\n        }\n        this.clear();\n        if (this._startingSignature) {\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\n        } else {\n            this.fromData(data, true);\n        }\n      };\n      SignaturePad.prototype.redo = function () {\n        if (!this._history.length) return;\n        const data = this.toData();\n        data.push(this._history.pop());\n        this.clear();\n        if (this._startingSignature) {\n            this.fromDataURL(this._startingSignature, {}, () => this.fromData(data, true));\n        } else {\n            this.fromData(data, true);\n        }\n      };\n      SignaturePad.prototype.draw = function () {\n        this._ctx.globalCompositeOperation = "source-over";\n        this._isDrawing = true;\n      };\n      SignaturePad.prototype.erase = function () {\n        this._ctx.globalCompositeOperation = "destination-out";\n        this._isDrawing = false;\n      };\n      SignaturePad.prototype.fromDataURL = function (dataUrl, options, callback) {\n          var _this = this;\n          if (options === void 0) options = {};\n          var image = new Image();\n          var ratio = options.ratio || window.devicePixelRatio || 1;\n          var width = options.width || this.canvas.width / ratio;\n          var height = options.height || this.canvas.height / ratio;\n          this._reset();\n          image.src = dataUrl;\n          image.onload = function () {\n            _this._ctx.globalCompositeOperation = "source-over";\n            _this._ctx.drawImage(image, 0, 0, width, height);\n            _this._ctx.globalCompositeOperation = _this._isDrawing ? "source-over" : "destination-out";\n              if (callback) {\n                  callback();\n              }\n          };\n          image.onerror = function (error) {\n              if (callback) {\n                  callback(error);\n              }\n          };\n          this._isEmpty = false;\n          if (!this._startingSignature) this._startingSignature = dataUrl;\n      };\n      SignaturePad.prototype.toDataURL = function (type = "image/png", encoderOptions) {\n        return type === "image/svg+xml" ? this._toSVG() : this.canvas.toDataURL(type, encoderOptions);\n      };\n      SignaturePad.prototype.on = function () {\n          this.canvas.style.touchAction = \'none\';\n          this.canvas.style.msTouchAction = \'none\';\n          if (window.PointerEvent) {\n              this._handlePointerEvents();\n          }\n          else {\n              this._handleMouseEvents();\n              if (\'ontouchstart\' in window) {\n                  this._handleTouchEvents();\n              }\n          }\n      };\n      SignaturePad.prototype.off = function () {\n          this.canvas.style.touchAction = \'auto\';\n          this.canvas.style.msTouchAction = \'auto\';\n          this.canvas.removeEventListener(\'pointerdown\', this._handleMouseDown);\n          this.canvas.removeEventListener(\'pointermove\', this._handleMouseMove);\n          document.removeEventListener(\'pointerup\', this._handleMouseUp);\n          this.canvas.removeEventListener(\'mousedown\', this._handleMouseDown);\n          this.canvas.removeEventListener(\'mousemove\', this._handleMouseMove);\n          document.removeEventListener(\'mouseup\', this._handleMouseUp);\n          this.canvas.removeEventListener(\'touchstart\', this._handleTouchStart);\n          this.canvas.removeEventListener(\'touchmove\', this._handleTouchMove);\n          this.canvas.removeEventListener(\'touchend\', this._handleTouchEnd);\n      };\n      SignaturePad.prototype.isEmpty = function () {\n          return this._isEmpty;\n      };\n      SignaturePad.prototype.fromData = function (pointGroups, suppressClear = false) {\n        var _this = this;\n        if (!suppressClear) this.clear();\n        if (pointGroups && pointGroups.length > 0) {\n          this._fromData(\n            pointGroups,\n            ({ color, curve }) => _this._drawCurve({ color, curve }),\n            ({ color, point, dotSize }) => _this._drawDot({ color, point, dotSize })\n          );\n          this._data = pointGroups;\n        }\n      };\n      SignaturePad.prototype.toData = function () {\n          return this._data;\n      };\n      SignaturePad.prototype._strokeBegin = function (event) {\n        var newPointGroup = {\n          color: this.penColor,\n          dotSize: typeof this.dotSize === \'function\' ? this.dotSize() : this.dotSize,\n          minWidth: this.minWidth,\n          maxWidth: this.maxWidth,\n          compositeOperation: this._ctx.globalCompositeOperation,\n          points: [],\n        };\n        if (typeof this.onBegin === "function") {\n          this.onBegin(event);\n        }\n        this._data.push(newPointGroup);\n        this._history = [];\n        this._reset();\n        this._strokeUpdate(event);\n      };\n      SignaturePad.prototype._strokeUpdate = function (event) {\n          var x = event.clientX;\n          var y = event.clientY;\n          var point = this._createPoint(x, y);\n          var lastPointGroup = this._data[this._data.length - 1];\n          var lastPoints = lastPointGroup.points;\n          var lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n          var isLastPointTooClose = lastPoint\n              ? point.distanceTo(lastPoint) <= this.minDistance\n              : false;\n          var color = lastPointGroup.color;\n          if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n              var curve = this._addPoint(point);\n              if (!lastPoint) {\n                  this._drawDot({ color, point });\n              }\n              else if (curve) {\n                  this._drawCurve({ color, curve });\n              }\n              lastPoints.push({\n                  time: point.time,\n                  x: point.x,\n                  y: point.y\n              });\n          }\n      };\n      SignaturePad.prototype._strokeEnd = function (event) {\n          this._strokeUpdate(event);\n          if (typeof this.onEnd === \'function\') {\n              this.onEnd(event);\n          }\n      };\n      SignaturePad.prototype._handlePointerEvents = function () {\n          this._mouseButtonDown = false;\n          this.canvas.addEventListener(\'pointerdown\', this._handleMouseDown);\n          this.canvas.addEventListener(\'pointermove\', this._handleMouseMove);\n          document.addEventListener(\'pointerup\', this._handleMouseUp);\n      };\n      SignaturePad.prototype._handleMouseEvents = function () {\n          this._mouseButtonDown = false;\n          this.canvas.addEventListener(\'mousedown\', this._handleMouseDown);\n          this.canvas.addEventListener(\'mousemove\', this._handleMouseMove);\n          document.addEventListener(\'mouseup\', this._handleMouseUp);\n      };\n      SignaturePad.prototype._handleTouchEvents = function () {\n          this.canvas.addEventListener(\'touchstart\', this._handleTouchStart);\n          this.canvas.addEventListener(\'touchmove\', this._handleTouchMove);\n          this.canvas.addEventListener(\'touchend\', this._handleTouchEnd);\n      };\n      SignaturePad.prototype._reset = function () {\n          this._lastPoints = [];\n          this._lastVelocity = 0;\n          this._lastWidth = typeof this.dotSize === \'function\' ? this.dotSize() : this.dotSize;\n          this._ctx.fillStyle = this.penColor;\n      };\n      SignaturePad.prototype._createPoint = function (x, y) {\n          var rect = this.canvas.getBoundingClientRect();\n          if (<%orientation%>) {\n            return new Point(y - rect.top, rect.left+rect.width-x, new Date().getTime());\n          } else {\n            return new Point(x - rect.left, y - rect.top, new Date().getTime());\n          }\n      };\n      SignaturePad.prototype._addPoint = function (point, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          var _lastPoints = this._lastPoints;\n          _lastPoints.push(point);\n          if (_lastPoints.length > 2) {\n              if (_lastPoints.length === 3) {\n                  _lastPoints.unshift(_lastPoints[0]);\n              }\n              var widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], minWidth, maxWidth);\n              var curve = Bezier.fromPoints(_lastPoints, widths);\n              _lastPoints.shift();\n              return curve;\n          }\n          return null;\n      };\n      SignaturePad.prototype._calculateCurveWidths = function (startPoint, endPoint, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          var velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +\n              (1 - this.velocityFilterWeight) * this._lastVelocity;\n          var newWidth = this._strokeWidth(velocity, minWidth, maxWidth);\n          var widths = {\n              end: newWidth,\n              start: this._lastWidth\n          };\n          this._lastVelocity = velocity;\n          this._lastWidth = newWidth;\n          return widths;\n      };\n      SignaturePad.prototype._strokeWidth = function (velocity, minWidth = this.minWidth, maxWidth = this.maxWidth) {\n          return Math.max(maxWidth / (velocity + 1), minWidth);\n      };\n      SignaturePad.prototype._drawCurveSegment = function (x, y, width) {\n          var ctx = this._ctx;\n          ctx.moveTo(x, y);\n          ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n          this._isEmpty = false;\n      };\n      SignaturePad.prototype._drawCurve = function (_a) {\n          var color = _a.color, curve = _a.curve;\n          var ctx = this._ctx;\n          var widthDelta = curve.endWidth - curve.startWidth;\n          var drawSteps = Math.floor(curve.length()) * 2;\n          ctx.beginPath();\n          ctx.fillStyle = color;\n          for (var i = 0; i < drawSteps; i += 1) {\n              var t = i / drawSteps;\n              var tt = t * t;\n              var ttt = tt * t;\n              var u = 1 - t;\n              var uu = u * u;\n              var uuu = uu * u;\n              var x = uuu * curve.startPoint.x;\n              x += 3 * uu * t * curve.control1.x;\n              x += 3 * u * tt * curve.control2.x;\n              x += ttt * curve.endPoint.x;\n              var y = uuu * curve.startPoint.y;\n              y += 3 * uu * t * curve.control1.y;\n              y += 3 * u * tt * curve.control2.y;\n              y += ttt * curve.endPoint.y;\n              var width = curve.startWidth + ttt * widthDelta;\n              this._drawCurveSegment(x, y, width);\n          }\n          ctx.closePath();\n          ctx.fill();\n      };\n      SignaturePad.prototype._drawDot = function (_a) {\n        var color = _a.color, point = _a.point;\n        var ctx = this._ctx;\n        var width = _a.dotSize ? _a.dotSize : typeof this.dotSize === "function" ? this.dotSize() : this.dotSize;\n        ctx.beginPath();\n        this._drawCurveSegment(point.x, point.y, width);\n        ctx.closePath();\n        ctx.fillStyle = color;\n        ctx.fill();\n      };\n      SignaturePad.prototype._fromData = function (pointGroups, drawCurve, drawDot) {\n        for (var i = 0; i < pointGroups.length; i++) {\n          var group = pointGroups[i];\n          var color = group.color, points = group.points;\n          var minWidth = group.minWidth, maxWidth = group.maxWidth, dotSize = group.dotSize;\n          var compositeOperation = group.compositeOperation;\n          this._reset();\n          this._lastWidth = dotSize;\n          if (points.length > 1) {\n            for (var j = 0; j < points.length; j++) {\n              var point = new Point(points[j].x, points[j].y, points[j].time);\n              this._ctx.globalCompositeOperation = compositeOperation;\n              var curve = this._addPoint(point, minWidth, maxWidth);\n              if (curve) drawCurve({ color, curve });\n            };\n          } else drawDot({ color, point: points[0], dotSize });\n        };\n        this._ctx.globalCompositeOperation = this._isDrawing ? "source-over" : "destination-out";\n      };\n      SignaturePad.prototype._toSVG = function () {\n          var _this = this;\n          var pointGroups = this._data;\n          var ratio = Math.max(window.devicePixelRatio || 1, 1);\n          var minX = 0;\n          var minY = 0;\n          var maxX = this.canvas.width / ratio;\n          var maxY = this.canvas.height / ratio;\n          var svg = document.createElementNS(\'http://www.w3.org/2000/svg\', \'svg\');\n          svg.setAttribute(\'width\', this.canvas.width.toString());\n          svg.setAttribute(\'height\', this.canvas.height.toString());\n          this._fromData(pointGroups, function (_a) {\n              var color = _a.color, curve = _a.curve;\n              var path = document.createElement("path");\n              if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n                var attr = "M " + curve.startPoint.x.toFixed(3) + "," + curve.startPoint.y.toFixed(3) + " " + ("C " + curve.control1.x.toFixed(3) + "," + curve.control1.y.toFixed(3) + " ") + (curve.control2.x.toFixed(3) + "," + curve.control2.y.toFixed(3) + " ") + (curve.endPoint.x.toFixed(3) + "," + curve.endPoint.y.toFixed(3));\n                path.setAttribute("d", attr);\n                path.setAttribute("stroke-width", (curve.endWidth * 2.25).toFixed(3));\n                path.setAttribute("stroke", color);\n                path.setAttribute("fill", "none");\n                path.setAttribute("stroke-linecap", "round");\n                svg.appendChild(path);\n              }\n            },\n            function (_a) {\n              var color = _a.color,point = _a.point;\n              var circle = document.createElement("circle");\n              var dotSize = _a.dotSize ? _a.dotSize : typeof _this.dotSize === "function" ? _this.dotSize() : _this.dotSize;\n              circle.setAttribute("r", dotSize.toString());\n              circle.setAttribute("cx", point.x.toString());\n              circle.setAttribute("cy", point.y.toString());\n              circle.setAttribute("fill", color);\n              svg.appendChild(circle);\n            }\n          );\n          var prefix = \'data:image/svg+xml;base64,\';\n          var header = \'<svg\' +\n              \' xmlns="http://www.w3.org/2000/svg"\' +\n              \' xmlns:xlink="http://www.w3.org/1999/xlink"\' +\n              (" viewBox=\\"" + minX + " " + minY + " " + maxX + " " + maxY + "\\"") +\n              (" width=\\"" + maxX + "\\"") +\n              (" height=\\"" + maxY + "\\"") +\n              \'>\';\n          var body = svg.innerHTML;\n          if (body === undefined) {\n              var dummy = document.createElement(\'dummy\');\n              var nodes = svg.childNodes;\n              dummy.innerHTML = \'\';\n              for (var i = 0; i < nodes.length; i += 1) {\n                  dummy.appendChild(nodes[i].cloneNode(true));\n              }\n              body = dummy.innerHTML;\n          }\n          var footer = \'</svg>\';\n          var data = header + body + footer;\n          return prefix + btoa(data);\n      };\n      return SignaturePad;\n  }());\n\n  return SignaturePad;\n\n})));\n'},4131:function(n,t,e){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return E}});var i=e(82367),o=e(55481),a=e(19180),r=e(34352),s=e(14056),c=a._(e(84653)),d=e(73083),u=o._(e(50590)),l=o._(e(17751)),h=o._(e(9152)),p=e(68989),v="BEGIN",g="END",m="EMPTY",f="CLEAR",y="UNDO",w="REDO",x="DRAW",b="ERASE",_="CHANGE_PEN",P="CHANGE_PEN_SIZE",S=d.StyleSheet.create({webBg:{width:"100%",backgroundColor:"transparent",flex:1},loadingOverlayContainer:{position:"absolute",top:0,bottom:0,left:0,right:0,alignItems:"center",justifyContent:"center"}}),W=(0,c.forwardRef)(function(n,t){var e=n.androidHardwareAccelerationDisabled,o=void 0!==e&&e,a=n.autoClear,W=void 0!==a&&a,E=n.backgroundColor,C=void 0===E?"":E,D=n.bgHeight,k=void 0===D?0:D,M=n.bgWidth,z=void 0===M?0:M,L=n.bgSrc,R=void 0===L?null:L,T=n.clearText,N=void 0===T?"Clear":T,A=n.confirmText,B=void 0===A?"Confirm":A,U=n.customHtml,O=void 0===U?null:U,V=n.dataURL,G=void 0===V?"":V,H=n.descriptionText,j=void 0===H?"Sign above":H,F=n.dotSize,I=void 0===F?null:F,q=n.imageType,Y=void 0===q?"":q,X=n.minWidth,$=void 0===X?.5:X,J=n.maxWidth,K=void 0===J?2.5:J,Z=n.minDistance,Q=void 0===Z?5:Z,nn=n.nestedScrollEnabled,tn=void 0!==nn&&nn,en=n.showsVerticalScrollIndicator,on=void 0===en||en,an=n.onOK,rn=void 0===an?function(){}:an,sn=n.onEmpty,cn=void 0===sn?function(){}:sn,dn=n.onClear,un=void 0===dn?function(){}:dn,ln=n.onUndo,hn=void 0===ln?function(){}:ln,pn=n.onRedo,vn=void 0===pn?function(){}:pn,gn=n.onDraw,mn=void 0===gn?function(){}:gn,fn=n.onErase,yn=void 0===fn?function(){}:fn,wn=n.onGetData,xn=void 0===wn?function(){}:wn,bn=n.onChangePenColor,_n=void 0===bn?function(){}:bn,Pn=n.onChangePenSize,Sn=void 0===Pn?function(){}:Pn,Wn=n.onBegin,En=void 0===Wn?function(){}:Wn,Cn=n.onEnd,Dn=void 0===Cn?function(){}:Cn,kn=n.onLoadEnd,Mn=void 0===kn?function(){}:kn,zn=n.onError,Ln=void 0===zn?function(){}:zn,Rn=n.overlayHeight,Tn=void 0===Rn?0:Rn,Nn=n.overlayWidth,An=void 0===Nn?0:Nn,Bn=n.overlaySrc,Un=void 0===Bn?null:Bn,On=n.penColor,Vn=void 0===On?"":On,Gn=n.rotated,Hn=void 0!==Gn&&Gn,jn=n.style,Fn=void 0===jn?null:jn,In=n.scrollable,qn=void 0!==In&&In,Yn=n.trimWhitespace,Xn=void 0!==Yn&&Yn,$n=n.webStyle,Jn=void 0===$n?"":$n,Kn=n.webviewContainerStyle,Zn=void 0===Kn?null:Kn,Qn=n.androidLayerType,nt=void 0===Qn?"hardware":Qn,tt=n.webviewProps,et=void 0===tt?{}:tt,it=r._((0,c.useState)(!0),2),ot=it[0],at=it[1],rt=r._((0,c.useState)(!1),2),st=rt[0],ct=rt[1],dt=r._((0,c.useState)(0),2),ut=dt[0],lt=dt[1],ht=(0,c.useRef)(),pt=(0,c.useMemo)(function(){var n=l.default+h.default;return n=(n=(n=(n=(n=(n=(n=(n=(n=(n=(n=n.replace(/<%autoClear%>/g,W)).replace(/<%trimWhitespace%>/g,Xn)).replace(/<%imageType%>/g,Y||"image/png")).replace(/<%dataURL%>/g,G||"")).replace(/<%penColor%>/g,Vn||"black")).replace(/<%backgroundColor%>/g,C||"rgba(255,255,255,0)")).replace(/<%dotSize%>/g,I||"null")).replace(/<%minWidth%>/g,$||.5)).replace(/<%maxWidth%>/g,K||2.5)).replace(/<%minDistance%>/g,Q||5)).replace(/<%orientation%>/g,Hn||!1)},[W,Xn,Y,G,Vn,C,I,$,K,Q,Hn]),vt=(0,c.useMemo)(function(){var n=(O||u.default)(pt);return{html:n=(n=(n=(n=(n=(n=(n=(n=(n=(n=(n=n.replace(/<%bgWidth%>/g,z||0)).replace(/<%bgHeight%>/g,k||0)).replace(/<%bgSrc%>/g,R||"null")).replace(/<%overlayWidth%>/g,An||0)).replace(/<%overlayHeight%>/g,Tn||0)).replace(/<%overlaySrc%>/g,Un||"null")).replace(/<%style%>/g,Jn||"")).replace(/<%description%>/g,j||"Sign above")).replace(/<%confirm%>/g,B||"Confirm")).replace(/<%clear%>/g,N||"Clear")).replace(/<%orientation%>/g,Hn||!1)}},[pt,O,z,k,R,An,Tn,Un,Jn,j,B,N,Hn]),gt=r._((0,c.useState)(!1),2),mt=gt[0],ft=gt[1];(0,c.useEffect)(function(){ft(!0)},[vt]),(0,c.useEffect)(function(){if(mt&&ht.current)try{ht.current.reload(),ft(!1)}catch(n){console.warn("WebView reload failed:",n)}},[mt]);var yt=(0,c.useCallback)(function(n){var t;if(null==n||null==(t=n.nativeEvent)?void 0:t.data){var e=n.nativeEvent.data;try{switch(e){case v:En();break;case g:Dn();break;case m:cn();break;case f:un();break;case y:hn();break;case w:vn();break;case x:mn();break;case b:yn();break;case _:_n();break;case P:Sn();break;default:!function(n){try{JSON.parse(n)}catch(n){return!1}return!0}(e)?"string"==typeof e&&e.startsWith("data:")?rn(e):console.warn("Unknown message type:",e):xn(e)}}catch(n){console.error("Error handling WebView message:",n)}}else console.warn("Invalid message received from WebView")},[En,Dn,cn,un,hn,vn,mn,yn,_n,Sn,xn,rn]),wt=(0,c.useCallback)(function(n){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];if(ht.current)try{var e=t.length>0?`${n}(${t.map(function(n){return"string"==typeof n?`'${n}'`:n}).join(",")});true;`:`${n}();true;`;ht.current.injectJavaScript(e)}catch(t){console.error(`Error executing WebView method ${n}:`,t)}else console.warn(`WebView ref is null when calling ${n}`)},[]);(0,c.useImperativeHandle)(t,function(){return{readSignature:function(){return wt("readSignature")},clearSignature:function(){return wt("clearSignature")},undo:function(){return wt("undo")},redo:function(){return wt("redo")},draw:function(){return wt("draw")},erase:function(){return wt("erase")},changePenColor:function(n){"string"==typeof n?wt("changePenColor",[n]):console.warn("changePenColor: color must be a string")},changePenSize:function(n,t){"number"==typeof n&&"number"==typeof t?wt("changePenSize",[n,t]):console.warn("changePenSize: minW and maxW must be numbers")},getData:function(){return wt("getData")},fromData:function(n){n?wt("fromData",[n,!1]):console.warn("fromData: pointGroups must be an array")}}},[wt]);var xt=(0,c.useCallback)(function(n){var t=n.nativeEvent;console.error("WebView error: ",t),ct(!0);try{Ln(new Error(`WebView error: ${t.description||t.code}`))}catch(n){console.warn("Error in onError callback:",n)}ht.current&&-999!==t.code&&ut<3&&setTimeout(function(){try{lt(function(n){return n+1}),ht.current.reload(),ct(!1)}catch(n){console.error("Failed to reload WebView after error:",n)}},Math.min(1e3*Math.pow(2,ut),5e3))},[Ln,ut,3]),bt=(0,c.useCallback)(function(){at(!1),ct(!1),lt(0);try{Mn()}catch(n){console.warn("Error in onLoadEnd callback:",n)}},[Mn]),_t=(0,c.useCallback)(function(){at(!0)},[]),Pt=(0,c.useCallback)(function(n){1===n.nativeEvent.progress&&at(!1)},[]);return(0,s.jsxs)(d.View,{style:[S.webBg,Fn],children:[(0,s.jsx)(p.WebView,i._({ref:ht,source:vt,onMessage:yt,onError:xt,onLoadEnd:bt,onLoadStart:_t,onLoadProgress:Pt,javaScriptEnabled:!0,useWebKit:!0,bounces:!1,style:[Zn],scrollEnabled:qn,androidLayerType:nt,androidHardwareAccelerationDisabled:o,nestedScrollEnabled:tn,showsVerticalScrollIndicator:on,cacheEnabled:!0,allowsInlineMediaPlayback:!1,mediaPlaybackRequiresUserAction:!0,allowsBackForwardNavigationGestures:!1,allowsLinkPreview:!1,allowFileAccess:!1,allowFileAccessFromFileURLs:!1,allowUniversalAccessFromFileURLs:!1,mixedContentMode:"never",originWhitelist:["*"],startInLoadingState:!0},et)),(ot||st)&&(0,s.jsx)(d.View,{style:S.loadingOverlayContainer,children:st?(0,s.jsxs)(d.Text,{style:{color:"#ff0000",textAlign:"center",padding:10},children:["Error loading signature pad",ut>0?` (Retry ${ut}/3)`:""]}):(0,s.jsx)(d.ActivityIndicator,{color:"#007AFF",size:"small"})})]})}),E=W}}]);//# sourceMappingURL=vendors-node_modules_react-native-signature-canvas_index_js.chunk.bundle.map?platform=android